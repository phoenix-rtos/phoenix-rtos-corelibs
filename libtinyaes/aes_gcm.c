/*
 * Phoenix-RTOS
 *
 * AES128-GCM encryption, decryption and signing
 *
 * Copyright 2023 Phoenix Systems
 * Author: Jan Wi≈õniewski
 *
 * Based on NIST publication https://doi.org/10.6028/NIST.SP.800-38D and
 * libtomcrypt AES-GCM implementation.
 *
 * This is code is optimized for size. It uses tinyaes AES for encryption and
 * simplest / smallest subset of libtomcrypt functions for GMAC calculation.
 * Libtomcrypt has higher level functions that could be used if there is need
 * for more aggressive speed optimization. Both AES and GMAC have alternative
 * implementations that use precalculated lookup tables.
 *
 * %LICENSE%
 */

#include <string.h>
#include <stdint.h>
#include <assert.h>

#include "tinyaes/aes.h"
#include "tinyaes/aes_gcm.h"

/* GCM multiplication is copied from libtomcrypt
 * webpage: https://www.libtom.net/LibTomCrypt/
 * repo: https://github.com/libtom/libtomcrypt
 * commit: 29986d04f2dca985ee64fbca1c7431ea3e3422f4
 * license: Public Domain */

#define STORE64H(x, y) \
	do { \
		(y)[0] = (uint8_t)(((x) >> 56) & 255); \
		(y)[1] = (uint8_t)(((x) >> 48) & 255); \
		(y)[2] = (uint8_t)(((x) >> 40) & 255); \
		(y)[3] = (uint8_t)(((x) >> 32) & 255); \
		(y)[4] = (uint8_t)(((x) >> 24) & 255); \
		(y)[5] = (uint8_t)(((x) >> 16) & 255); \
		(y)[6] = (uint8_t)(((x) >> 8) & 255); \
		(y)[7] = (uint8_t)((x)&255); \
	} while (0)


/* right shift */
static void s_gcm_rightshift(uint8_t *a)
{
	int x;
	for (x = 15; x > 0; x--) {
		a[x] = (a[x] >> 1) | ((a[x - 1] << 7) & 0x80);
	}
	a[0] >>= 1;
}


static const uint8_t mask[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
static const uint8_t poly[] = { 0x00, 0xE1 };


/* smallest GCM GF multiplication from libtomcrypt/src/encauth/gcm/gcm_mult_h.c */
static void gcm_gf_mult(const uint8_t *a, const uint8_t *b, uint8_t *c)
{
	uint8_t Z[16], V[16];
	uint8_t x, y, z;

	memset(Z, 0, 16);
	memcpy(V, a, 16);
	for (x = 0; x < 128; x++) {
		if (b[x >> 3] & mask[x & 7]) {
			for (y = 0; y < 16; y++) {
				Z[y] ^= V[y];
			}
		}
		z = V[15] & 0x01;
		s_gcm_rightshift(V);
		V[0] ^= poly[z];
	}
	memcpy(c, Z, 16);
}


static void gmac_add_data(const uint8_t *H, uint8_t *X, const uint8_t *data, size_t len)
{
	while (len > 0) {
		for (int b = 0; b < 16 && len > 0; b++) {
			X[b] ^= *data;
			data += 1;
			len -= 1;
		}
		gcm_gf_mult(H, X, X);
	}
}


/* initial counter counter values (appended to IV)
 * J0: for encrypting tag
 * ICB: for encrypting ciphertext
 * */
#define CTR_J0  1
#define CTR_ICB 2


static inline void init_ctr(struct AES_ctx *aes_ctx, const uint8_t *iv12, uint32_t ctr)
{
	uint8_t block[16];
	/* preparing pre-counter block (J0) */
	/* for 96 bit IV this is done by concatenating IV with this constant: */
	memcpy(block, iv12, 12);
	block[12] = ctr >> 24;
	block[13] = ctr >> 16;
	block[14] = ctr >> 8;
	block[15] = ctr;
	AES_ctx_set_iv(aes_ctx, block);
}


void AES_GCM_init(struct AES_ctx *aes_ctx, const uint8_t *key)
{
	assert(aes_ctx != NULL && key != NULL);
	AES_init_ctx(aes_ctx, key);
}


void AES_GCM_mac(struct AES_ctx *aes_ctx, const uint8_t *iv12, const uint8_t *aad, size_t aad_len, const uint8_t *ctext, size_t ctext_len, uint8_t *tag_out)
{
	assert(iv12 != NULL && (aad_len == 0 || aad != NULL) && (ctext_len == 0 || ctext != NULL));

	/* H - GMAC multiplication key - generated by encrypting zero block with AES_ECB */
	uint8_t subkey_h[16] = { 0 };
	AES_ECB_encrypt(aes_ctx, subkey_h);

	memset(tag_out, 0, 16);
	gmac_add_data(subkey_h, tag_out, aad, aad_len);
	gmac_add_data(subkey_h, tag_out, ctext, ctext_len);

	/* final data added to GMAC: len(A) || len(C) */
	uint8_t len_block[16];
	STORE64H(aad_len * (uint64_t)8, len_block);
	STORE64H(ctext_len * (uint64_t)8, len_block + 8);
	gmac_add_data(subkey_h, tag_out, len_block, 16);

	/* last step - encrypting with initial counter value  */
	init_ctr(aes_ctx, iv12, CTR_J0);
	AES_CTR_xcrypt_buffer(aes_ctx, tag_out, 16);
}


void AES_GCM_crypt(struct AES_ctx *aes_ctx, const uint8_t *iv12, uint8_t *xtext, size_t xtext_len)
{
	assert(iv12 != NULL && (xtext_len == 0 || xtext != NULL));

	/* GCM requires incrementation of only lower 32 bits of counter (mod 2^32) */
	/* it is easier to disallow longer messages that implement this custom CTR wrapping */
	assert(xtext_len / 16 <= UINT32_MAX - 1);

	init_ctr(aes_ctx, iv12, CTR_ICB);
	AES_CTR_xcrypt_buffer(aes_ctx, xtext, xtext_len);
}
